---
title: "ベストプラクティス: 設定の最適化 | opencode-dynamic-context-pruning"
subtitle: "ベストプラクティス: 設定の最適化"
sidebarTitle: "Token を 40% 節約"
description: "DCP のベストプラクティス設定方法を学習します。戦略の選択、ターン保護、ツール保護、通知モード設定を習得し、Token 使用を最適化します。"
tags:
  - "ベストプラクティス"
  - "Token 節約"
  - "設定"
  - "最適化"
prerequisite:
  - "start-configuration"
  - "platforms-auto-pruning"
order: 2
---

# DCP ベストプラクティス

## 学習目標

- Prompt Caching と Token 節約のトレードオフを理解する
- 保護戦略（ターン保護、保護ツール、ファイルモード）を選択する
- コマンドを使用して Token 使用を手動で最適化する
- プロジェクトの要件に合わせて DCP 設定をカスタマイズする

## Prompt Caching のトレードオフ

### キャッシュとトリミングのトレードオフを理解する

DCP がツール出力をトリミングするとメッセージ内容が変更され、これにより**正確なプレフィックス一致**に基づく Prompt Caching がその時点から前方で無効になります。

**テストデータの比較**：

| シナリオ           | キャッシュヒット率 | Token 節約 | 総合利益 |
|--- | --- | --- | ---|
| DCP なし         | ~85%      | 0%        | ベースライン   |
| DCP 有効化       | ~65%      | 20-40%    | ✅ 正の利益 |

### いつキャッシュ損失を無視すべきか

**DCP の使用が推奨されるシナリオ**：

- ✅ **長い会話**（20 回転を超える）：コンテキストの膨張が顕著で、Token 節約がキャッシュ損失を上回る
- ✅ **リクエストごとの課金**サービス：GitHub Copilot、Google Antigravity などキャッシュ損失に悪影響がない
- ✅ **頻繁なツール呼び出し**：頻繁なファイル読み取り、検索実行などのシナリオ
- ✅ **コードリファクタリングタスク**：同じファイルを繰り返し読み取るシナリオが頻繁

**DCP を無効にする必要がある可能性があるシナリオ**：

- ⚠️ **短い会話**（< 10 回転）：トリミングの利益が限定的で、キャッシュ損失がより顕著になる可能性がある
- ⚠️ **キャッシュに敏感なタスク**：キャッシュヒット率を最大化する必要があるシナリオ（バッチ処理タスクなど）

::: tip 柔軟な設定
プロジェクトの要件に応じて DCP 設定を動的に調整でき、プロジェクトレベルの設定で特定の戦略を無効にすることもできます。
:::

---

## 設定優先度のベストプラクティス

### マルチレベル設定の正しい使用

DCP 設定は以下の優先度でマージされます：

```
デフォルト値 < グローバル設定 < カスタム設定ディレクトリ < プロジェクト設定
```

::: info 設定ディレクトリの説明
「カスタム設定ディレクトリ」は `$OPENCODE_CONFIG_DIR` 環境変数を設定して指定するディレクトリです。このディレクトリには `dcp.jsonc` または `dcp.json` ファイルを配置する必要があります。
:::

### 推奨される設定戦略

| シナリオ             | 推奨設定場所 | 設定の重点                     |
|--- | --- | ---|
| **個人開発環境**   | グローバル設定    | 自動戦略を有効化、デバッグログを無効化          |
| **チーム協力プロジェクト**   | プロジェクト設定    | プロジェクト固有の保護ファイル、戦略スイッチ         |
| **CI/CD 環境**   | カスタム設定ディレクトリ  | 通知を無効化、デバッグログを有効化             |
| **一時的なデバッグ**       | プロジェクト設定    | `debug` を有効化、詳細通知モード           |

**例：プロジェクトレベル設定のオーバーライド**

```jsonc
// ~/.config/opencode/dcp.jsonc（グローバル設定）
{
    "enabled": true,
    "strategies": {
        "deduplication": {
            "enabled": true
        }
    }
}
```

```jsonc
// .opencode/dcp.jsonc（プロジェクト設定）
{
    "strategies": {
        // プロジェクトレベルオーバーライド：重複排除を無効化（プロジェクトが履歴コンテキストを保持する必要がある場合など）
        "deduplication": {
            "enabled": false
        }
    }
}
```

::: warning 設定変更後の再起動
設定変更後は OpenCode を再起動する必要があります。
:::

---

## 保護戦略の選択

### ターン保護の使用シナリオ

**ターン保護**（Turn Protection）はツールが指定されたターン数以内でトリミングされるのを防ぎ、AI に最近のコンテンツを参照する十分な時間を与えます。

**推奨設定**：

| シナリオ                   | 推奨値    | 理由                     |
|--- | --- | ---|
| **複雑な問題解決**       | 4-6 ターン | AI がツール出力を複数回反復分析する必要がある      |
| **コードリファクタリング**           | 2-3 ターン | コンテキストの切り替えが速く、保護期間が長すぎると効果に影響    |
| **迅速なプロトタイプ開発**       | 2-4 ターン | 保護と Token 節約のバランス        |
| **デフォルト設定**           | 4 ターン    | テスト済みのバランスポイント              |

**ターン保護を有効にするタイミング**：

```jsonc
{
    "turnProtection": {
        "enabled": true,   // ターン保護を有効化
        "turns": 6        // 6 ターンを保護（複雑なタスクに適）
    }
}
```

**有効にしないことが推奨される場合**：

- 簡単な質問回答シナリオ（AI が直接回答し、ツールを必要としない）
- 高頻度の短い会話（保護期間が長すぎるとトリミングが遅れる）

### 保護ツールの設定

**デフォルトの保護ツール**（追加設定不要）：
- `task`、`write`、`edit`、`batch`、`discard`、`extract`、`todowrite`、`todoread`、`plan_enter`、`plan_exit`

::: warning Schema デフォルト値の説明
IDE の自動補完機能を使用する場合、Schema ファイル（`dcp.schema.json`）のデフォルト保護ツールリストが不完全に表示される可能性があります。実際にはソースコードで定義された `DEFAULT_PROTECTED_TOOLS` が優先され、すべての 10 個のツールが含まれます。
:::

**追加の保護ツールを追加するタイミング**：

| シナリオ                   | 設定例                              | 理由                     |
|--- | --- | ---|
| **重要なビジネスツール**       | `protectedTools: ["critical_tool"]` | 重要な操作が常に可視であることを保証            |
| **履歴コンテキストが必要なツール** | `protectedTools: ["analyze_history"]` | 分析のために完全な履歴を保持            |
| **カスタムタスクツール**     | `protectedTools: ["custom_task"]` | カスタムタスクのワークフローを保護            |

```jsonc
{
    "strategies": {
        "deduplication": {
            "enabled": true,
            "protectedTools": ["custom_analyze"]  // 特定のツールを追加保護
        }
    },
    "tools": {
        "settings": {
            "protectedTools": ["important_check"]  // LLM ツールの追加保護
        }
    }
}
```

### 保護ファイルパターンの使用

**推奨される保護パターン**：

| ファイルタイプ             | 推奨パターン                     | 保護理由                 |
|--- | --- | ---|
| **設定ファイル**           | `"*.env"`, `".env*"`        | 機密情報がトリミングで失われるのを防ぐ          |
| **データベース設定**          | `"**/config/database/*"`    | データベース接続設定が常に利用可能であることを保証        |
| **シークレットファイル**           | `"**/secrets/**"`          | すべてのシークレットと証明書を保護            |
| **コアビジネスロジック**        | `"src/core/*"`            | 重要なコードコンテキストの損失を防ぐ          |

```jsonc
{
    "protectedFilePatterns": [
        "*.env",                // すべての環境変数ファイルを保護
        ".env.*",              // .env.local などを含む
        "**/secrets/**",       // secrets ディレクトリを保護
        "**/config/*.json",    // 設定ファイルを保護
        "src/auth/**"          // 認証関連コードを保護
    ]
}
```

::: tip パターンマッチングルール
`protectedFilePatterns` はツールパラメータの `filePath` フィールド（`read`、`write`、`edit` ツールなど）に一致します。
:::

---

## 自動戦略の選択

### 重複排除戦略（Deduplication）

**デフォルトで有効**、ほとんどのシナリオに適しています。

**適用シナリオ**：
- 同じファイルを繰り返し読み取る（コードレビュー、複数回のデバッグなど）
- 同じ検索または分析コマンドを実行する

**有効にしないことが推奨される場合**：
- 各呼び出しの正確な出力を保持する必要がある（パフォーマンス監視など）
- ツール出力にタイムスタンプまたはランダム値が含まれる（呼び出しごとに異なる）

### 上書き書き込み戦略（Supersede Writes）

**デフォルトで無効**、プロジェクトの要件に応じて有効にするかどうかを決定します。

**有効にすることが推奨されるシナリオ**：
- ファイル変更後に直ちに読み取って検証する（リファクタリング、バッチ処理）
- 書き込み操作の出力が大きく、読み取り後にその価値が上書きされる

```jsonc
{
    "strategies": {
        "supersedeWrites": {
            "enabled": true  // 上書き書き込み戦略を有効化
        }
    }
}
```

**有効にしないことが推奨される場合**：
- ファイル変更履歴を追跡する必要がある（コード監査）
- 書き込み操作に重要なメタデータが含まれる（変更理由など）

### エラー消去戦略（Purge Errors）

**デフォルトで有効**、有効な状態を維持することが推奨されます。

**設定の推奨**：

| シナリオ                   | 推奨値  | 理由                     |
|--- | --- | ---|
| **デフォルト設定**           | 4 ターン | テスト済みのバランスポイント              |
| **高速失敗シナリオ**       | 2 ターン | エラー入力を早期にクリアし、コンテキスト汚染を低減       |
| **エラー履歴が必要**       | 6-8 ターン | デバッグのためにより多くのエラー情報を保持する          |

```jsonc
{
    "strategies": {
        "purgeErrors": {
            "enabled": true,
            "turns": 2  // 高速失敗シナリオ：2 ターン後にエラー入力をクリア
        }
    }
}
```

---

## LLM 駆動ツールのベストプラクティス

### ナッジ機能の最適化

DCP はデフォルトで 10 回のツール呼び出しごとに AI にトリミングツールを使用するようリマインドします。

**推奨設定**：

| シナリオ                   | nudgeFrequency | 効果の説明                |
|--- | --- | ---|
| **頻繁なツール呼び出し**       | 8-12          | AI に適時にクリアを促す            |
| **低頻度のツール呼び出し**       | 15-20         | リマインドの干渉を減らす              |
| **ナッジを無効化**           | Infinity      | AI の自律的判断に完全に依存         |

```jsonc
{
    "tools": {
        "settings": {
            "nudgeEnabled": true,
            "nudgeFrequency": 15  // 低頻度シナリオ：15 回のツール呼び出し後にリマインド
        }
    }
}
```

### Extract ツールの使用

**Extract を使用するタイミング**：
- ツール出力に重要な発見またはデータが含まれ、要約を保持する必要がある
- 元の出力が大きいが、抽出された情報が後続の推論を支えるのに十分

**設定の推奨**：

```jsonc
{
    "tools": {
        "extract": {
            "enabled": true,
            "showDistillation": false  // デフォルトでは抽出内容を表示しない（干渉を低減）
        }
    }
}
```

**`showDistillation` を有効にするタイミング**：
- AI がどの重要情報を抽出したかを確認する必要がある
- Extract ツールの動作をデバッグまたは検証する

### Discard ツールの使用

**Discard を使用するタイミング**：
- ツール出力が一時的な状態またはノイズに過ぎない
- タスク完了後にツール出力を保持する必要がない

**設定の推奨**：

```jsonc
{
    "tools": {
        "discard": {
            "enabled": true
        }
    }
}
```

---

## コマンド使用のヒント

### `/dcp context` を使用するタイミング

**推奨される使用シナリオ**：
- Token 使用量が異常であると疑う場合
- 現在のセッションのコンテキスト分布を知る必要がある
- DCP のトリミング効果を評価する

**ベストプラクティス**：
- 長い会話の途中で一度チェックし、コンテキストの構成を理解する
- 会話の終了時にチェックし、総 Token 消費量を確認する

### `/dcp stats` を使用するタイミング

**推奨される使用シナリオ**：
- 長期的な Token 節約効果を知る必要がある
- DCP の全体的な価値を評価する
- 異なる設定の節約効果を比較する

**ベストプラクティス**：
- 毎週一度、累積統計データを確認する
- 設定最適化後に前後の効果を比較する

### `/dcp sweep` を使用するタイミング

**推奨される使用シナリオ**：
- コンテキストが大きすぎて応答が遅くなる
- Token 消費を直ちに減らす必要がある
- 自動戦略がトリミングをトリガーしない

**使用のヒント**：

| コマンド              | 用途               |
|--- | ---|
| `/dcp sweep`      | 直前のユーザーメッセージ以降のすべてのツールをトリミング |
| `/dcp sweep 10`   | 最後の 10 個のツールのみトリミング      |
| `/dcp sweep 5`    | 最後の 5 個のツールのみトリミング       |

**推奨されるワークフロー**：
1. まず `/dcp context` を使用して現在の状態を確認
2. 状況に応じてトリミング数を決定
3. `/dcp sweep N` を使用してトリミングを実行
4. 再度 `/dcp context` を使用して効果を確認

---

## 通知モードの選択

### 3 つの通知モードの比較

| モード       | 表示内容                          | 適用シナリオ             |
|--- | --- | ---|
| **off**   | 通知を表示しない                       | 干渉を必要としない作業環境      |
| **minimal** | トリミング数と Token 節約のみ表示             | 効果を知りたいが詳細は不要    |
| **detailed** | トリミングされた各ツールと理由を表示（デフォルト）          | デバッグまたは詳細な監視が必要なシナリオ   |

### 推奨設定

| シナリオ             | 推奨モード   | 理由               |
|--- | --- | ---|
| **日常開発**       | minimal | 効果に注目、干渉を低減        |
| **問題のデバッグ**       | detailed | 各トリミング操作の理由を確認      |
| **デモまたはデモ録画**  | off     | 通知によるデモフローの干渉を回避       |

```jsonc
{
    "pruneNotification": "minimal"  // 日常開発に推奨
}
```

---

## サブエージェントシナリオの処理

### サブエージェントの制限を理解する

**DCP はサブエージェントセッションで完全に無効化されます**。

**理由**：
- サブエージェントの目標は簡潔な発見の要約を返すこと
- DCP のトリミングはサブエージェントの要約動作を干渉する可能性がある
- サブエージェントは通常実行時間が短く、コンテキストの膨張が限定的

### サブエージェントセッションかどうかを判断する方法

1. **デバッグログを有効化**：
    ```jsonc
    {
        "debug": true
    }
    ```

2. **ログを確認**：
    ログに `isSubAgent: true` マークが表示されます

### サブエージェントの Token 最適化の提案

DCP はサブエージェントで無効化されますが、以下のことが可能です：

- サブエージェントのプロンプトを最適化し、出力長を減らす
- サブエージェントのツール呼び出し範囲を制限する
- `task` ツールの `max_length` パラメータを使用して出力を制御する

---

## まとめ

| ベストプラクティス領域       | コア提案                          |
|--- | ---|
| **Prompt Caching**  | 長い会話では Token 節約が通常キャッシュ損失を上回る          |
| **設定優先度**      | グローバル設定は汎用設定に、プロジェクト設定は特定の要件に         |
| **ターン保護**       | 複雑なタスクは 4-6 ターン、高速タスクは 2-3 ターン         |
| **保護ツール**     | デフォルト保護で十分、必要に応じて重要なビジネスツールを追加             |
| **保護ファイル**     | 設定、シークレット、コアビジネスロジックファイルを保護               |
| **自動戦略**       | 重複排除とエラー消去はデフォルトで有効、上書き書き込みは必要に応じて有効化           |
| **LLM ツール**     | ナッジ頻度 10-15 回、Extract はデバッグ時に抽出内容を表示    |
| **コマンド使用**     | 定期的にコンテキストを確認し、必要に応じて手動トリミング                |
| **通知モード**       | 日常開発は minimal、デバッグは detailed       |

---

## 付録：ソースコード参照

<details>
<summary><strong>クリックしてソースコードの場所を表示</strong></summary>

> 更新日時：2026-01-23

| 機能         | ファイルパス                                                                                              | 行号        |
|--- | --- | ---|
| 設定ママージ      | [`lib/config.ts`](https://github.com/Opencode-DCP/opencode-dynamic-context-pruning/blob/main/lib/config.ts#L691-794)    | 691-794     |
| 設定検証      | [`lib/config.ts`](https://github.com/Opencode-DCP/opencode-dynamic-context-pruning/blob/main/lib/config.ts#L147-375)    | 147-375     |
| デフォルト設定      | [`lib/config.ts`](https://github.com/Opencode-DCP/opencode-dynamic-context-pruning/blob/main/lib/config.ts#L68-134)     | 68-134      |
| ターン保護      | [`lib/config.ts`](https://github.com/Opencode-DCP/opencode-dynamic-context-pruning/blob/main/lib/config.ts#L432-437)   | 432-437     |
| 保護ツール     | [`lib/config.ts`](https://github.com/Opencode-DCP/opencode-dynamic-context-pruning/blob/main/lib/config.ts#L68-79)     | 68-79       |
| 保護ファイルパターン   | [`protected-file-patterns.ts`](https://github.com/Opencode-DCP/opencode-dynamic-context-pruning/blob/main/lib/protected-file-patterns.ts#L1-60) | 1-60        |
| サブエージェント検出     | [`lib/state/utils.ts`](https://github.com/Opencode-DCP/opencode-dynamic-context-pruning/blob/main/lib/state/utils.ts#L1-8)      | 1-8         |
| ナッジ機能      | [`lib/config.ts`](https://github.com/Opencode-DCP/opencode-dynamic-context-pruning/blob/main/lib/config.ts#L438-441)   | 438-441     |

**重要な定数**：
- `MAX_TOOL_CACHE_SIZE = 1000`：ツールキャッシュの最大エントリ数
- `turnProtection.turns`：デフォルト 4 ターン保護

**重要な関数**：
- `getConfig()`：マルチレベル設定を読み込み、マージする
- `validateConfigTypes()`：設定項目の型を検証する
- `mergeConfig()`：優先度で設定をマージする
- `isSubAgentSession()`：サブエージェントセッションを検出する

</details>

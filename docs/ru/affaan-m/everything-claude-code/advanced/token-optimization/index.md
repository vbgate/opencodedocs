---
title: "Оптимизация токенов: контекстное окно | Everything Claude Code"
sidebarTitle: "Что делать при переполнении контекста"
subtitle: "Оптимизация токенов: контекстное окно"
description: "Изучите стратегии оптимизации токенов в Claude Code. Освойте выбор модели, стратегическое сжатие и настройку MCP для максимальной эффективности контекстного окна и качества ответов."
tags:
  - "token-optimization"
  - "context-management"
  - "performance"
prerequisite:
  - "start-quick-start"
order: 110
---

# Стратегии оптимизации токенов: управление контекстным окном

## Чему вы научитесь

- Выбирать подходящую модель в зависимости от типа задачи, балансируя стоимость и производительность
- Использовать стратегическое сжатие для сохранения ключевого контекста на логических границах
- Правильно настраивать MCP-серверы, избегая чрезмерного потребления контекстного окна
- Предотвращать переполнение контекстного окна и поддерживать качество ответов

## Ваша текущая проблема

Сталкивались ли вы с этими ситуациями?

- Посреди диалога контекст внезапно сжимается, и важная информация теряется
- Включено слишком много MCP-серверов, и контекстное окно сократилось с 200k до 70k
- При масштабном рефакторинге модель «забывает» предыдущие обсуждения
- Непонятно, когда нужно сжимать контекст, а когда — нет

## Когда применять эти методы

- **При работе со сложными задачами** — выбирайте подходящую модель и стратегию управления контекстом
- **При приближении к лимиту контекстного окна** — используйте стратегическое сжатие для сохранения ключевой информации
- **При настройке MCP-серверов** — балансируйте количество инструментов и ёмкость контекста
- **При длительных сессиях** — сжимайте на логических границах, избегая автоматического сжатия с потерей данных

## Основная идея

Суть оптимизации токенов не в том, чтобы «использовать меньше», а в том, чтобы **сохранять ценную информацию в критические моменты**.

### Три столпа оптимизации

1. **Стратегия выбора модели** — разные задачи требуют разных моделей, не стоит «стрелять из пушки по воробьям»
2. **Стратегическое сжатие** — сжимайте на логических границах, а не в произвольный момент
3. **Управление конфигурацией MCP** — контролируйте количество активных инструментов, защищая контекстное окно

### Ключевые концепции

::: info Что такое контекстное окно?

Контекстное окно — это объём истории диалога, который Claude Code может «помнить». Текущие модели поддерживают около 200k токенов, но на это влияют следующие факторы:

- **Включённые MCP-серверы** — каждый MCP занимает место в системном промпте
- **Загруженные Skills** — определения навыков занимают контекст
- **История диалога** — записи вашего общения с Claude

Когда контекст приближается к лимиту, Claude автоматически сжимает историю, что может привести к потере важной информации.
:::

::: tip Почему ручное сжатие лучше?

Автоматическое сжатие Claude срабатывает в произвольный момент, часто прерывая рабочий процесс посреди задачи. Стратегическое сжатие позволяет вам самостоятельно выбирать момент на **логических границах** (например, после завершения планирования или перед переключением задач), сохраняя важный контекст.
:::

## Пошаговое руководство

### Шаг 1: Выберите подходящую модель

Выбирайте модель в зависимости от сложности задачи, избегая лишних затрат и расхода контекста.

**Зачем**

Разные модели существенно отличаются по способности к рассуждению и стоимости. Правильный выбор экономит значительное количество токенов.

**Руководство по выбору модели**

| Модель | Область применения | Стоимость | Способность к рассуждению |
| --- | --- | --- | --- |
| **Haiku 4.5** | Лёгкие агенты, частые вызовы, генерация кода | Низкая (1/3 от Sonnet) | 90% возможностей Sonnet |
| **Sonnet 4.5** | Основная разработка, сложные задачи кодирования, оркестрация | Средняя | Лучшая модель для кодирования |
| **Opus 4.5** | Архитектурные решения, глубокий анализ, исследования | Высокая | Максимальная способность к рассуждению |

**Способ настройки**

В файле агента в директории `agents/` укажите:

```markdown
---
name: planner
description: Планирование шагов реализации сложных функций
model: opus
---

Вы — продвинутый планировщик...
```

**Ожидаемый результат**:
- Задачи с глубоким анализом (например, проектирование архитектуры) используют Opus — более высокое качество
- Задачи кодирования используют Sonnet — оптимальное соотношение цены и качества
- Часто вызываемые worker-агенты используют Haiku — экономия затрат

### Шаг 2: Включите хук стратегического сжатия

Настройте хук для напоминания о сжатии контекста на логических границах.

**Зачем**

Автоматическое сжатие срабатывает в произвольный момент и может привести к потере важной информации. Стратегическое сжатие позволяет вам контролировать момент сжатия.

**Шаги настройки**

Убедитесь, что в `hooks/hooks.json` есть конфигурации PreToolUse и PreCompact:

```json
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "tool == \"Edit\" || tool == \"Write\"",
        "hooks": [
          {
            "type": "command",
            "command": "node \"${CLAUDE_PLUGIN_ROOT}/scripts/hooks/suggest-compact.js\""
          }
        ],
        "description": "Suggest manual compaction at logical intervals"
      }
    ],
    "PreCompact": [
      {
        "matcher": "*",
        "hooks": [
          {
            "type": "command",
            "command": "node \"${CLAUDE_PLUGIN_ROOT}/scripts/hooks/pre-compact.js\""
          }
        ],
        "description": "Save state before context compaction"
      }
    ]
  }
}
```

**Настройка порога**

Установите переменную окружения `COMPACT_THRESHOLD` для управления частотой рекомендаций (по умолчанию 50 вызовов инструментов):

```json
// Добавьте в ~/.claude/settings.json
{
  "env": {
    "COMPACT_THRESHOLD": "50"  // Первая рекомендация после 50 вызовов инструментов
  }
}
```

**Ожидаемый результат**:
- После каждого редактирования или записи файла хук подсчитывает количество вызовов инструментов
- При достижении порога (по умолчанию 50) вы увидите сообщение:
  ```
  [StrategicCompact] 50 tool calls reached - consider /compact if transitioning phases
  ```
- Затем каждые 25 вызовов инструментов появляется сообщение:
  ```
  [StrategicCompact] 75 tool calls - good checkpoint for /compact if context is stale
  ```

### Шаг 3: Сжимайте на логических границах

Следуя подсказкам хука, выполняйте ручное сжатие в подходящий момент.

**Зачем**

Сжатие после переключения задач или завершения этапа позволяет сохранить ключевой контекст и удалить избыточную информацию.

**Руководство по выбору момента сжатия**

✅ **Рекомендуемые моменты для сжатия**:
- После завершения планирования, перед началом реализации
- После завершения функционального этапа, перед началом следующего
- После завершения отладки, перед продолжением разработки
- При переключении на другой тип задачи

❌ **Избегайте сжатия**:
- В процессе реализации функции
- Посреди отладки проблемы
- Во время редактирования нескольких связанных файлов

**Порядок действий**

Когда появится подсказка хука:

1. Оцените текущий этап задачи
2. Если момент подходящий, выполните:
   ```bash
   /compact
   ```
3. Дождитесь, пока Claude обобщит контекст
4. Убедитесь, что ключевая информация сохранена

**Ожидаемый результат**:
- После сжатия контекстное окно освобождает значительный объём
- Ключевая информация (план реализации, завершённые функции) сохраняется
- Новое взаимодействие начинается с компактного контекста

### Шаг 4: Оптимизируйте конфигурацию MCP

Контролируйте количество включённых MCP-серверов для защиты контекстного окна.

**Зачем**

Каждый MCP-сервер занимает место в системном промпте. Слишком много активных серверов значительно сокращают контекстное окно.

**Принципы настройки**

Согласно рекомендациям из README:

```json
{
  "mcpServers": {
    // Можно настроить 20-30 MCP...
    "github": { ... },
    "supabase": { ... },
    // ...дополнительные конфигурации
  },
  "disabledMcpServers": [
    "firecrawl",       // Отключите редко используемые MCP
    "clickhouse",
    // ...отключайте в зависимости от потребностей проекта
  ]
}
```

**Лучшие практики**:

- **Настройте все MCP** (20-30 штук) для гибкого переключения между проектами
- **Держите активными < 10 MCP**, общее количество инструментов < 80
- **Выбирайте по проекту**: при работе с бэкендом включайте инструменты для баз данных, при работе с фронтендом — инструменты сборки

**Способ проверки**

Проверьте количество инструментов:

```bash
// Claude Code покажет текущие активные инструменты
/tool list
```

**Ожидаемый результат**:
- Общее количество инструментов < 80
- Контекстное окно остаётся на уровне 180k+ (избегайте падения ниже 70k)
- Динамически корректируйте список активных инструментов в зависимости от проекта

### Шаг 5: Интеграция с Memory Persistence

Используйте хуки для сохранения критического состояния после сжатия.

**Зачем**

Стратегическое сжатие удаляет контекст, но критическое состояние (план реализации, контрольные точки) должно сохраняться.

**Настройка хуков**

Убедитесь, что следующие хуки включены:

```json
{
  "hooks": {
    "SessionStart": [
      {
        "matcher": "*",
        "hooks": [
          {
            "type": "command",
            "command": "node \"${CLAUDE_PLUGIN_ROOT}/scripts/hooks/session-start.js\""
          }
        ],
        "description": "Load previous context and detect package manager on new session"
      }
    ],
    "SessionEnd": [
      {
        "matcher": "*",
        "hooks": [
          {
            "type": "command",
            "command": "node \"${CLAUDE_PLUGIN_ROOT}/scripts/hooks/session-end.js\""
          }
        ],
        "description": "Persist session state on end"
      }
    ]
  }
}
```

**Рабочий процесс**:

1. После завершения задачи используйте `/checkpoint` для сохранения состояния
2. Перед сжатием контекста хук PreCompact автоматически сохраняет данные
3. При запуске новой сессии хук SessionStart автоматически загружает данные
4. Критическая информация (планы, состояние) сохраняется независимо от сжатия

**Ожидаемый результат**:
- После сжатия важное состояние остаётся доступным
- Новая сессия автоматически восстанавливает предыдущий контекст
- Ключевые решения и планы реализации не теряются

## Контрольный список ✅

- [ ] Настроен хук `strategic-compact`
- [ ] Модель выбирается в зависимости от задачи (Haiku/Sonnet/Opus)
- [ ] Активных MCP < 10, общее количество инструментов < 80
- [ ] Сжатие выполняется на логических границах (после планирования/этапов)
- [ ] Хуки Memory Persistence включены, критическое состояние сохраняется

## Типичные ошибки

### ❌ Ошибка 1: Использование Opus для всех задач

**Проблема**: Opus — самая мощная модель, но её стоимость в 10 раз выше Sonnet и в 30 раз выше Haiku.

**Решение**: Выбирайте модель в зависимости от типа задачи:
- Часто вызываемые агенты (ревью кода, форматирование) — Haiku
- Основная разработка — Sonnet
- Архитектурные решения, глубокий анализ — Opus

### ❌ Ошибка 2: Игнорирование подсказок хука о сжатии

**Проблема**: После появления сообщения `[StrategicCompact]` работа продолжается, контекст в итоге сжимается автоматически, и важная информация теряется.

**Решение**: Оцените этап задачи и выполните `/compact` в подходящий момент.

### ❌ Ошибка 3: Включение всех MCP-серверов

**Проблема**: Настроено 20+ MCP, и все включены — контекстное окно сократилось с 200k до 70k.

**Решение**: Используйте `disabledMcpServers` для отключения редко используемых MCP, держите активными < 10 MCP.

### ❌ Ошибка 4: Сжатие в процессе реализации

**Проблема**: Контекст сжат во время реализации функции, и модель «забыла» предыдущие обсуждения.

**Решение**: Сжимайте только на логических границах (после планирования, при переключении задач, после завершения этапа).

## Итоги урока

Суть оптимизации токенов — **сохранять ценную информацию в критические моменты**:

1. **Выбор модели** — Haiku/Sonnet/Opus имеют свои области применения, правильный выбор экономит затраты
2. **Стратегическое сжатие** — ручное сжатие на логических границах предотвращает потерю информации при автоматическом сжатии
3. **Управление MCP** — контролируйте количество активных серверов для защиты контекстного окна
4. **Memory Persistence** — критическое состояние остаётся доступным после сжатия

Следуя этим стратегиям, вы максимизируете эффективность контекста Claude Code и избежите снижения качества из-за переполнения контекста.

## Анонс следующего урока

> В следующем уроке мы изучим **[Цикл верификации: Checkpoint и Evals](../verification-loop/)**.
>
> Вы узнаете:
> - Как использовать Checkpoint для сохранения и восстановления рабочего состояния
> - Метод Eval Harness для непрерывной верификации
> - Типы Grader и метрику Pass@K
> - Применение цикла верификации в TDD

---

## Приложение: Справочник по исходному коду

<details>
<summary><strong>Нажмите, чтобы развернуть расположение исходного кода</strong></summary>

> Дата обновления: 2026-01-25

| Функция | Путь к файлу | Строки |
| --- | --- | --- |
| Skill стратегического сжатия | [`skills/strategic-compact/SKILL.md`](https://github.com/affaan-m/everything-claude-code/blob/main/skills/strategic-compact/SKILL.md) | 1-64 |
| Хук рекомендации сжатия | [`scripts/hooks/suggest-compact.js`](https://github.com/affaan-m/everything-claude-code/blob/main/scripts/hooks/suggest-compact.js) | 1-61 |
| Хук сохранения перед сжатием | [`scripts/hooks/pre-compact.js`](https://github.com/affaan-m/everything-claude-code/blob/main/scripts/hooks/pre-compact.js) | 1-49 |
| Правила оптимизации производительности | [`rules/performance.md`](https://github.com/affaan-m/everything-claude-code/blob/main/rules/performance.md) | 1-48 |
| Конфигурация хуков | [`hooks/hooks.json`](https://github.com/affaan-m/everything-claude-code/blob/main/hooks/hooks.json) | 1-158 |
| Описание контекстного окна | [`README.md`](https://github.com/affaan-m/everything-claude-code/blob/main/README.md) | 349-359 |

**Ключевые константы**:
- `COMPACT_THRESHOLD = 50`: Порог вызовов инструментов (значение по умолчанию)
- `MCP_LIMIT = 10`: Рекомендуемый лимит активных MCP
- `TOOL_LIMIT = 80`: Рекомендуемый лимит общего количества инструментов

**Ключевые функции**:
- `suggest-compact.js:main()`: Подсчёт вызовов инструментов и рекомендация сжатия
- `pre-compact.js:main()`: Сохранение состояния сессии перед сжатием

</details>

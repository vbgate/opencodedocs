---
title: "Автоматическая очистка: три стратегии | opencode-dcp"
sidebarTitle: "Экономия токенов"
subtitle: "Автоматическая очистка: три стратегии | opencode-dcp"
description: "Изучите три стратегии автоматической очистки DCP: дедупликация, перезапись и очистка ошибок. Подробное объяснение принципов работы, сценариев применения и методов настройки для экономии токенов и повышения качества диалога. Все стратегии без затрат на LLM."
tags:
  - "автоматическая очистка"
  - "стратегии"
  - "дедупликация"
  - "перезапись"
  - "очистка ошибок"
prerequisite:
  - "start-getting-started"
  - "start-configuration"
order: 1
---

# Подробное руководство по стратегиям автоматической очистки

## Чему вы научитесь

- Понимать принципы работы трёх стратегий автоматической очистки
- Знать, когда включать или отключать каждую стратегию
- Оптимизировать эффективность стратегий через настройку

## Ваша текущая проблема

По мере удлинения диалога вызовы инструментов накапливаются в контексте:
- ИИ многократно читает один и тот же файл, каждый раз добавляя полное содержимое в контекст
- После записи файла и его чтения старое содержимое записи остаётся в контексте без дела
- После неудачного вызова инструмента громоздкие входные параметры продолжают занимать место

Эти проблемы приводят к росту счетов за токены и могут «загрязнять» контекст, влияя на решения ИИ.

## Основная идея

DCP предоставляет три **стратегии автоматической очистки**, которые выполняются незаметно перед каждым запросом, **без затрат на LLM**:

| Стратегия | По умолчанию | Назначение |
| --- | --- | --- |
| Дедупликация | ✅ Включена | Обнаруживает повторяющиеся вызовы инструментов, сохраняет только последний |
| Перезапись | ❌ Отключена | Очищает входные данные операций записи, перезаписанных чтением |
| Очистка ошибок | ✅ Включена | Очищает входные данные ошибочных инструментов через N раундов |

Все стратегии следуют этим правилам:
- **Пропуск защищённых инструментов**: task, write, edit и другие ключевые инструменты не очищаются
- **Пропуск защищённых файлов**: пути файлов, защищённые настроенными glob-шаблонами
- **Сохранение сообщений об ошибках**: стратегия очистки ошибок удаляет только входные параметры, сообщения об ошибках сохраняются

---

## Стратегия дедупликации

### Принцип работы

Стратегия дедупликации обнаруживает повторяющиеся вызовы с **одинаковым именем инструмента и параметрами**, сохраняя только последний.

::: info Механизм сопоставления сигнатур

DCP определяет дубликаты по «сигнатуре»:
- Одинаковое имя инструмента
- Одинаковые значения параметров (null/undefined игнорируются, порядок ключей не влияет)

Например:
```json
// Первый вызов
{ "tool": "read", "path": "src/config.ts" }

// Второй вызов (сигнатура совпадает)
{ "tool": "read", "path": "src/config.ts" }

// Третий вызов (сигнатура отличается)
{ "tool": "read", "path": "src/utils.ts" }
```
:::

### Сценарии применения

**Рекомендуется включить** (включено по умолчанию):
- ИИ часто читает один и тот же файл для анализа кода
- Многократные запросы одной и той же конфигурации в ходе диалога
- Сценарии, где нужно актуальное состояние, а исторические выводы можно отбросить

**Возможно, стоит отключить**:
- Нужно сохранить контекст каждого вызова инструмента (например, для отладки вывода инструментов)

### Метод настройки

```json
// ~/.config/opencode/dcp.jsonc
{
  "$schema": "https://raw.githubusercontent.com/Opencode-DCP/opencode-dynamic-context-pruning/main/dcp.schema.json",
  "strategies": {
    "deduplication": {
      "enabled": true  // true — включить, false — отключить
    }
  }
}
```

**Защищённые инструменты** (не очищаются по умолчанию):
- task, write, edit, batch, plan_enter, plan_exit
- todowrite, todoread (инструменты списка задач)
- discard, extract (собственные инструменты DCP)

Эти инструменты не могут быть очищены дедупликацией даже через конфигурацию (жёстко закодированная защита).

---

## Стратегия перезаписи

### Принцип работы

Стратегия перезаписи очищает **входные данные операций записи, которые были перезаписаны последующим чтением**.

::: details Пример: запись с последующим чтением

```text
Шаг 1: Запись файла
ИИ вызывает write("config.json", {...})
↓
Шаг 2: Чтение файла для подтверждения
ИИ вызывает read("config.json") → возвращает актуальное содержимое
↓
Стратегия перезаписи распознаёт
Входные данные write (возможно, большие) становятся избыточными
потому что read уже захватил текущее состояние файла
↓
Очистка
Сохраняется только вывод read, входные данные write удаляются
```

:::

### Сценарии применения

**Рекомендуется включить**:
- Сценарии итеративной разработки с частым циклом «запись → проверка → изменение»
- Операции записи содержат большие шаблоны или полное содержимое файлов

**Причины отключения по умолчанию**:
- Некоторые рабочие процессы зависят от «истории записей» как контекста
- Может влиять на некоторые вызовы инструментов, связанных с контролем версий

**Когда включить вручную**:
```json
{
  "strategies": {
    "supersedeWrites": {
      "enabled": true
    }
  }
}
```

### Примечания

Эта стратегия **очищает только входные данные инструмента write**, не вывод. Потому что:
- Вывод write обычно является подтверждающим сообщением (очень маленьким)
- Входные данные write могут содержать полное содержимое файла (очень большое)

---

## Стратегия очистки ошибок

### Принцип работы

Стратегия очистки ошибок после неудачного вызова инструмента ждёт N раундов, затем удаляет **входные параметры** (сохраняя сообщения об ошибках).

::: info Что такое раунд (turn)?
В диалоге OpenCode:
- Пользователь отправляет сообщение → ИИ отвечает = 1 раунд
- Вызовы инструментов не считаются отдельными раундами

Порог по умолчанию — 4 раунда, что означает автоматическую очистку входных данных ошибочного инструмента через 4 раунда.
:::

### Сценарии применения

**Рекомендуется включить** (включено по умолчанию):
- Вызов инструмента не удался, а входные данные большие (например, неудачное чтение очень большого файла)
- Сообщение об ошибке нужно сохранить, но входные параметры больше не имеют ценности

**Возможно, стоит отключить**:
- Нужно сохранить полные входные данные неудачного инструмента для отладки
- Часто возникают «периодические» ошибки, и нужно сохранить историю

### Метод настройки

```json
{
  "strategies": {
    "purgeErrors": {
      "enabled": true,   // Переключатель включения
      "turns": 4        // Порог очистки (количество раундов)
    }
  }
}
```

**Защищённые инструменты** (не очищаются по умолчанию):
- Тот же список защищённых инструментов, что и для стратегии дедупликации

---

## Порядок выполнения стратегий

Три стратегии выполняются в **фиксированном порядке**:

```mermaid
graph LR
    A["Список сообщений"] --> B["Синхронизация кэша инструментов"]
    B --> C["Стратегия дедупликации"]
    C --> D["Стратегия перезаписи"]
    D --> E["Стратегия очистки ошибок"]
    E --> F["Замена очищенного содержимого"]
```

Это означает:
1. Сначала дедупликация (уменьшение избыточности)
2. Затем перезапись (очистка устаревших записей)
3. Наконец очистка ошибок (очистка устаревших ошибочных входных данных)

Каждая стратегия основывается на результатах предыдущей и не очищает один и тот же инструмент повторно.

---

## Типичные ошибки

### ❌ Заблуждение 1: Думать, что все инструменты очищаются автоматически

**Проблема**: Почему task, write и другие инструменты не очищаются?

**Причина**: Эти инструменты находятся в **списке защищённых инструментов**, жёстко закодированная защита.

**Решение**:
- Если действительно нужно очистить write, рассмотрите включение стратегии перезаписи
- Если нужно очистить task, можно косвенно контролировать через настройку защищённых путей файлов

### ❌ Заблуждение 2: Стратегия перезаписи приводит к неполному контексту

**Проблема**: После включения перезаписи ИИ не может найти предыдущее содержимое записи.

**Причина**: Стратегия очищает только операции записи, «перезаписанные чтением», но если после записи файл никогда не читался, он не будет очищен.

**Решение**:
- Проверьте, был ли файл действительно прочитан (можно посмотреть через `/dcp context`)
- Если действительно нужно сохранить записи, отключите эту стратегию

### ❌ Заблуждение 3: Стратегия очистки ошибок очищает слишком быстро

**Проблема**: Ошибочные входные данные только что очищены, а ИИ сразу же сталкивается с той же ошибкой.

**Причина**: Порог `turns` установлен слишком маленьким.

**Решение**:
```json
{
  "strategies": {
    "purgeErrors": {
      "turns": 8  // Увеличить с 4 по умолчанию до 8
    }
  }
}
```

---

## Когда использовать эти стратегии

| Сценарий | Рекомендуемая комбинация стратегий |
| --- | --- |
| Повседневная разработка (больше чтения, меньше записи) | Дедупликация + Очистка ошибок (конфигурация по умолчанию) |
| Частая запись и проверка | Все включены (вручную включить перезапись) |
| Отладка неудачных инструментов | Только дедупликация (отключить очистку ошибок) |
| Нужна полная история контекста | Все отключены |

---

## Итоги урока

- **Стратегия дедупликации**: обнаруживает повторяющиеся вызовы инструментов, сохраняет только последний (включена по умолчанию)
- **Стратегия перезаписи**: очищает входные данные операций записи, перезаписанных чтением (отключена по умолчанию)
- **Стратегия очистки ошибок**: очищает входные данные ошибочных инструментов через N раундов (включена по умолчанию, порог 4)
- Все стратегии пропускают защищённые инструменты и защищённые пути файлов
- Стратегии выполняются в фиксированном порядке: дедупликация → перезапись → очистка ошибок

---

## Анонс следующего урока

> В следующем уроке мы изучим **[Инструменты очистки на основе LLM](../llm-tools/)**.
>
> Вы узнаете:
> - Как ИИ самостоятельно вызывает инструменты discard и extract
> - Способы реализации семантической оптимизации контекста
> - Лучшие практики извлечения ключевых находок

---

## Приложение: Справочник по исходному коду

<details>
<summary><strong>Нажмите, чтобы развернуть расположение исходного кода</strong></summary>

> Дата обновления: 2026-01-23

| Функция | Путь к файлу | Строки |
| --- | --- | --- |
| Реализация стратегии дедупликации | [`lib/strategies/deduplication.ts`](https://github.com/Opencode-DCP/opencode-dynamic-context-pruning/blob/main/lib/strategies/deduplication.ts) | 13-83 |
| Реализация стратегии перезаписи | [`lib/strategies/supersede-writes.ts`](https://github.com/Opencode-DCP/opencode-dynamic-context-pruning/blob/main/lib/strategies/supersede-writes.ts) | 16-105 |
| Реализация стратегии очистки ошибок | [`lib/strategies/purge-errors.ts`](https://github.com/Opencode-DCP/opencode-dynamic-context-pruning/blob/main/lib/strategies/purge-errors.ts) | 16-80 |
| Экспорт точки входа стратегий | [`lib/strategies/index.ts`](https://github.com/Opencode-DCP/opencode-dynamic-context-pruning/blob/main/lib/strategies/index.ts) | 1-5 |
| Конфигурация по умолчанию | [`lib/config.ts`](https://github.com/Opencode-DCP/opencode-dynamic-context-pruning/blob/main/lib/config.ts) | 423-464 |
| Список защищённых инструментов | [`lib/config.ts`](https://github.com/Opencode-DCP/opencode-dynamic-context-pruning/blob/main/lib/config.ts) | 68-79 |

**Ключевые функции**:
- `deduplicate()` — главная функция стратегии дедупликации
- `supersedeWrites()` — главная функция стратегии перезаписи
- `purgeErrors()` — главная функция стратегии очистки ошибок
- `createToolSignature()` — создание сигнатуры инструмента для сопоставления дубликатов
- `normalizeParameters()` — нормализация параметров (удаление null/undefined)
- `sortObjectKeys()` — сортировка ключей параметров (обеспечение согласованности сигнатур)

**Значения конфигурации по умолчанию**:
- `strategies.deduplication.enabled = true`
- `strategies.supersedeWrites.enabled = false`
- `strategies.purgeErrors.enabled = true`
- `strategies.purgeErrors.turns = 4`

**Защищённые инструменты (не очищаются по умолчанию)**:
- task, todowrite, todoread, discard, extract, batch, write, edit, plan_enter, plan_exit

</details>

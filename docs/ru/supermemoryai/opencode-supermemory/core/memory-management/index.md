---
title: "Область памяти: жизненный цикл | opencode-supermemory"
sidebarTitle: "Область памяти"
subtitle: "Область памяти: жизненный цикл"
description: "Изучите области User и Project в opencode-supermemory. Освойте операции CRUD с памятью, реализуйте повторное использование опыта между проектами и изоляцию проектов."
tags:
  - "memory-management"
  - "scope"
  - "crud"
prerequisite:
  - "core-tools"
order: 3
---

# Область действия памяти и жизненный цикл: управление вашим цифровым мозгом

## Что вы сможете сделать после изучения

- **Различать области**: Понять, какие памяти "следуют за вами" (межпроектные), а какие "следуют за проектом" (специфичные для проекта).
- **Управлять памятью**: Научиться вручную просматривать, добавлять и удалять памяти, поддерживая чистоту познаний Agent.
- **Отладка Agent**: Когда Agent "запоминает" что-то неправильно, знать, где исправить.

## Основная идея

opencode-supermemory делит память на две изолированные **области (Scope)**, аналогично глобальным и локальным переменным в языках программирования.

### 1. Две области

| Область | Идентификатор (Scope ID) | Жизненный цикл | Типичное использование |
|--- | --- | --- | ---|
| **User Scope**<br>(Пользовательская область) | `user` | **Всегда следует за вами**<br>Общие для всех проектов | • Предпочтения стиля кодирования (например, "предпочитаю TypeScript")<br>• Личные привычки (например, "всегда пишу комментарии")<br>• Общие знания |
| **Project Scope**<br>(Область проекта) | `project` | **Только для текущего проекта**<br>Недействителен при смене каталога | • Дизайн архитектуры проекта<br>• Описание бизнес-логики<br>• Решение определенных багов |

::: info Как генерируются области?
Плагин автоматически генерирует уникальные теги через `src/services/tags.ts`:
- **User Scope**: На основе хеша вашего Git-адреса электронной почты (`opencode_user_{hash}`).
- **Project Scope**: На основе хеша пути к текущему проекту (`opencode_project_{hash}`).
:::

### 2. Жизненный цикл памяти

1.  **Создание (Add)**: Записывается через инициализацию CLI или диалог Agent (`Remember this...`).
2.  **Активация (Inject)**: При каждом запуске новой сессии плагин автоматически извлекает соответствующие User и Project памяти и внедряет их в контекст.
3.  **Поиск (Search)**: В процессе диалога Agent может активно искать конкретную память.
4.  **Забывание (Forget)**: Когда память устарела или неверна, удаляется по ID.

---

## Следуйте моему примеру: управление вашей памятью

Мы будем управлять памятью двух областей через диалог с Agent.

### Шаг 1: Просмотр существующей памяти

Сначала посмотрим, что Agent запомнил сейчас.

**Действие**: Введите в чате OpenCode:

```text
Пожалуйста, перечислите все памяти текущего проекта (List memories in project scope)
```

**Что вы должны увидеть**:
Agent вызывает режим `list` инструмента `supermemory` и возвращает список:

```json
// Пример вывода
{
  "success": true,
  "scope": "project",
  "count": 3,
  "memories": [
    {
      "id": "mem_123456",
      "content": "Проект использует MVC-архитектуру, слой Service отвечает за бизнес-логику",
      "createdAt": "2023-10-01T10:00:00Z"
    }
    // ...
  ]
}
```

### Шаг 2: Добавление межпроектной памяти (User Scope)

Предположим, вы хотите, чтобы Agent во **всех** проектах отвечал на русском языке. Это память, подходящая для User Scope.

**Действие**: Введите следующую команду:

```text
Пожалуйста, запомните мои личные предпочтения: независимо от проекта, всегда отвечайте мне на русском.
Пожалуйста, сохраните это в User Scope.
```

**Что вы должны увидеть**:
Agent вызывает инструмент `add` с параметром `scope: "user"`:

```json
{
  "mode": "add",
  "content": "User prefers responses in Russian across all projects",
  "scope": "user",
  "type": "preference"
}
```

Система подтверждает, что память добавлена, и возвращает `id`.

### Шаг 3: Добавление памяти, специфичной для проекта (Project Scope)

Теперь добавим конкретное правило для **текущего проекта**.

**Действие**: Введите следующую команду:

```text
Пожалуйста, запомните: в этом проекте все форматы даты должны быть YYYY-MM-DD.
Сохраните в Project Scope.
```

**Что вы должны увидеть**:
Agent вызывает инструмент `add` с параметром `scope: "project"` (это значение по умолчанию, Agent может опустить его):

```json
{
  "mode": "add",
  "content": "Date format must be YYYY-MM-DD in this project",
  "scope": "project",
  "type": "project-config"
}
```

### Шаг 4: Проверка изоляции

Чтобы убедиться, что область работает, попробуйте выполнить поиск.

**Действие**: Введите:

```text
Поиск памяти о "формате даты"
```

**Что вы должны увидеть**:
Agent вызывает инструмент `search`. Если он указал `scope: "project"` или выполняет смешанный поиск, он должен найти только что добавленную память.

::: tip Проверка межпроектной способности
Если вы создадите новое окно терминала, перейдете в другой другой каталог проекта и снова спросите о "формате даты", Agent должен **не найти** эту память (потому что она изолирована в Project Scope исходного проекта). Но если вы спросите "на каком языке вы предпочитаете отвечать", он должен найти предпочтение "ответ на русском языке" из User Scope.
:::

### Шаг 5: Удаление устаревшей памяти

Если стандарты проекта изменились, нам нужно удалить старую память.

**Действие**:
1. Сначала выполните **Шаг 1**, чтобы получить ID памяти (например, `mem_987654`).
2. Введите команду:

```text
Пожалуйста, забудьте память с ID mem_987654 о формате даты.
```

**Что вы должны увидеть**:
Agent вызывает инструмент `forget`:

```json
{
  "mode": "forget",
  "memoryId": "mem_987654"
}
```

Система возвращает `success: true`.

---

## Частые вопросы (FAQ)

### Q: Если я сменил компьютер, память User Scope останется?
**A: Зависит от вашей конфигурации Git.**
User Scope генерируется на основе `git config user.email`. Если вы используете один и тот же адрес электронной почты Git на двух компьютерах и подключаетесь к одной и той же учетной записи Supermemory (используя один и тот же API Key), то память **синхронизирована**.

### Q: Почему я не вижу только что добавленную память?
**A: Возможна задержка кэша или индексации.**
Векторный индекс Supermemory обычно имеет задержку в секундах, но при колебаниях сети может быть кратковременная задержка. Кроме того, контекст, который Agent внедряет в начале сессии, является **статическим** (снимком), новые добавленные памяти могут потребовать перезапуска сессии (`/clear` или перезапуск OpenCode), чтобы они вступили в силу в "автоматическом внедрении", но через инструмент `search` можно найти немедленно.

---

## Приложение: справочник по исходному коду

<details>
<summary><strong>Нажмите, чтобы просмотреть расположение исходного кода</strong></summary>

> Время обновления: 2026-01-23

| Функция | Путь к файлу | Номер строки |
|--- | --- | ---|
| Логика генерации Scope | [`src/services/tags.ts`](https://github.com/supermemoryai/opencode-supermemory/blob/main/src/services/tags.ts#L18-L36) | 18-36 |
| Определение инструмента памяти | [`src/index.ts`](https://github.com/supermemoryai/opencode-supermemory/blob/main/src/index.ts#L183-L485) | 183-485 |
| Определение типа памяти | [`src/types/index.ts`](https://github.com/supermemoryai/opencode-supermemory/blob/main/src/types/index.ts) | - |
| Реализация клиента | [`src/services/client.ts`](https://github.com/supermemoryai/opencode-supermemory/blob/main/src/services/client.ts) | 23-182 |

**Ключевые функции**:
- `getUserTag()`: Генерация пользовательского тега на основе Git-адреса электронной почты
- `getProjectTag()`: Генерация тега проекта на основе пути к каталогу
- `supermemoryClient.addMemory()`: Вызов API добавления памяти
- `supermemoryClient.deleteMemory()`: Вызов API удаления памяти

</details>

## Предпросмотр следующего урока

> В следующем уроке мы изучим **[Принцип упреждающего сжатия](../../advanced/compaction/index.md)**.
>
> Вы узнаете:
> - Почему Agent "забывает" (переполнение контекста)
> - Как плагин автоматически обнаруживает использование токенов
> - Как сжимать сессию без потери ключевой информации

---
title: "Контекст: внедрение | opencode-supermemory"
sidebarTitle: "Внедрение"
subtitle: "Контекст: внедрение | opencode-supermemory"
description: "Изучите внедрение контекста opencode-supermemory. Agent получает профиль и знания о проекте в начале сессии. Управляйте памятью через ключевые слова."
tags:
  - "Контекст"
  - "Внедрение"
  - "prompt"
  - "Память"
prerequisite:
  - "start-getting-started"
order: 1
---

# Механизм автоматического внедрения контекста: позвольте Agent "предвидеть"

## Что вы сможете сделать после изучения

После изучения этого урока вы сможете:
1.  **Понять**, почему Agent с самого начала знает ваши привычки кодирования и архитектуру проекта.
2.  **Освоить** "трехмерную модель" внедрения контекста (профиль пользователя, знания о проекте, релевантная память).
3.  **Научиться** использовать ключевые слова (например, "Remember this") для активного вмешательства в поведение запоминания Agent.
4.  **Настроить** количество внедряемых элементов, балансируя длину контекста и информативность.

---

## Основная идея

До появления плагина памяти в каждой новой сессии Agent был чистым листом. Вам приходилось повторять: "я использую TypeScript", "в этом проекте используется Next.js".

**Внедрение контекста (Context Injection)** решает эту проблему. Это как бы вставка "сводки задач" в мозг Agent в момент его пробуждения.

### Момент триггера

opencode-supermemory очень сдержан и автоматически внедряется только при **первом сообщении сессии**.

- **Почему первое сообщение?** Потому что это ключевой момент для определения тона сессии.
- **А последующие сообщения?** В последующие сообщения внедрение не происходит автоматически, чтобы не мешать потоку диалога, если вы не вызываете его активно (см. ниже "Триггеризация по ключевым словам").

### Трехмерная модель внедрения

Плагин параллельно получает три типа данных, объединяя их в блок подсказки `[SUPERMEMORY]`:

| Измерение данных | Источник | Функция | Пример |
| :--- | :--- | :--- | :--- |
| **1. Профиль пользователя** (Profile) | `getProfile` | Ваши долгосрочные предпочтения | "Пользователь предпочитает функциональное программирование", "предпочитает стрелочные функции" |
| **2. Знания о проекте** (Project) | `listMemories` | Глобальные знания о текущем проекте | "В этом проекте используется Clean Architecture", "API находится в src/api" |
| **3. Релевантная память** (Relevant) | `searchMemories` | Предыдущий опыт, релевантный вашему первому предложению | Вы спрашиваете "как исправить этот баг", он ищет предыдущие аналогичные записи о исправлении |

---

## Что внедряется?

Когда вы отправляете первое сообщение в OpenCode, плагин незаметно вставляет следующее содержимое в System Prompt.

::: details Нажмите, чтобы просмотреть реальную структуру внедренного содержимого
```text
[SUPERMEMORY]

User Profile:
- User prefers concise responses
- User uses Zod for all validations

Recent Context:
- Working on auth module refactoring

Project Knowledge:
- [100%] Architecture follows MVC pattern
- [100%] Use 'npm run test' for testing

Relevant Memories:
- [85%] Previous fix for hydration error: use useEffect
```
:::

После просмотра этой информации Agent будет вести себя как старый сотрудник, который давно работает над этим проектом, а не как новый стажер.

---

## Механизм триггеризации по ключевым словам (Nudge)

Помимо автоматического внедрения в начале, вы можете в любое время в процессе диалога "пробудить" функцию памяти.

Плагин имеет встроенный **детектор ключевых слов**. Пока ваше сообщение содержит определенный триггер, плагин отправит Agent "невидимую подсказку" (Nudge), заставляя его вызвать инструмент сохранения.

### Ключевые слова по умолчанию

- `remember`
- `save this`
- `don't forget`
- `memorize`
- `take note`
- ... (см. конфигурацию исходного кода для большего)

### Пример взаимодействия

**Вы вводите**:
> Формат ответа API здесь изменился, **remember** в дальнейшем используйте `data.result`, а не `data.payload`.

**Плагин обнаруживает "remember"**:
> (Внедрение подсказки в фоновом режиме): `[MEMORY TRIGGER DETECTED] The user wants you to remember something...`

**Реакция Agent**:
> Принято. Я запомню это изменение.
> *(Фоновый вызов `supermemory.add` для сохранения памяти)*

---

## Глубокая настройка

Вы можете изменить поведение внедрения, отредактировав `~/.config/opencode/supermemory.jsonc`.

### Распространенные параметры конфигурации

```jsonc
{
  // Внедрять ли профиль пользователя (по умолчанию true)
  "injectProfile": true,

  // Сколько элементов памяти проекта внедрять каждый раз (по умолчанию 10)
  // Увеличение позволит Agent лучше узнать проект, но потребует больше токенов
  "maxProjectMemories": 10,

  // Сколько элементов профиля пользователя внедрять каждый раз (по умолчанию 5)
  "maxProfileItems": 5,

  // Пользовательские ключевые слова (поддерживаются регулярные выражения)
  "keywordPatterns": [
    "запиши",
    "сохранить навсегда"
  ]
}
```

::: tip Совет
После изменения конфигурации нужно перезапустить OpenCode или перезагрузить плагин, чтобы изменения вступили в силу.
:::

---

## Частые вопросы

### Q: Внедренная информация занимает много токенов?
**A**: Занимает часть, но обычно контролируется. При конфигурации по умолчанию (10 элементов памяти проекта + 5 элементов профиля) занимает около 500-1000 токенов. Для современных больших моделей (например, Claude 3.5 Sonnet) с контекстом 200k это лишь капля в море.

### Q: Я сказал "remember", но он не реагирует?
**A**:
1. Проверьте правильность написания (поддерживается сопоставление регулярных выражений).
2. Убедитесь, что API Key настроен правильно (если плагин не инициализирован, триггер не сработает).
3. Agent может решить игнорировать (хотя плагин принудительно подсказал, но Agent имеет окончательное право).

### Q: Как находятся "релевантные памяти"?
**A**: Они находятся на основе семантического поиска по содержанию **вашего первого сообщения**. Если в первом предложении вы сказали только "Hi", возможно, не найдется полезной релевантной памяти, но "знания о проекте" и "профиль пользователя" все равно будут внедрены.

---

## Итог урока

- **Автоматическое внедрение** срабатывает только при первом сообщении сессии.
- **Трехмерная модель** включает профиль пользователя, знания о проекте и релевантную память.
- **Триггеризация по ключевым словам** позволяет вам в любое время приказать Agent сохранить память.
- Через **файл конфигурации** можно контролировать объем внедряемой информации.

## Предпросмотр следующего урока

> В следующем уроке мы изучим **[Набор инструментов: научить Agent запоминать](../tools/index.md)**.
>
> Вы узнаете:
> - Как вручную использовать инструменты `add`, `search` и т. д.
> - Как просматривать и удалять неправильные памяти.

---

## Приложение: справочник по исходному коду

<details>
<summary><strong>Нажмите, чтобы просмотреть расположение исходного кода</strong></summary>

> Время обновления: 2026-01-23

| Функция | Путь к файлу | Номер строки |
| :--- | :--- | :--- |
| Логика триггера внедрения | [`src/index.ts`](https://github.com/supermemoryai/opencode-supermemory/blob/main/src/index.ts#L125-L176) | 125-176 |
| Обнаружение ключевых слов | [`src/index.ts`](https://github.com/supermemoryai/opencode-supermemory/blob/main/src/index.ts#L34-L37) | 34-37 |
| Форматирование Prompt | [`src/services/context.ts`](https://github.com/supermemoryai/opencode-supermemory/blob/main/src/services/context.ts#L14-L64) | 14-64 |
| Конфигурация по умолчанию | [`src/config.ts`](https://github.com/supermemoryai/opencode-supermemory/blob/main/src/config.ts#L44-L54) | 44-54 |

**Ключевые функции**:
- `formatContextForPrompt()`: Сборка текстового блока `[SUPERMEMORY]`.
- `detectMemoryKeyword()`: Регулярное сопоставление ключевых слов в сообщении пользователя.

</details>

## Предпросмотр следующего урока

> В следующем уроке мы изучим **[Набор инструментов: научить Agent запоминать](../tools/index.md)**.
>
> Вы узнаете:
> - Овладеть 5 основными режимами инструментов: `add`, `search`, `profile`, `list`, `forget`
> - Как вручную вмешиваться и исправлять память Agent
> - Использовать естественный язык для триггерирования сохранения памяти

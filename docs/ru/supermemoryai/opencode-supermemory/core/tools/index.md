---
title: "Инструменты: научить Agent запоминать | opencode-supermemory"
sidebarTitle: "Инструменты"
subtitle: "Инструменты: научить Agent запоминать"
description: "Овладей 5 режимами supermemory (add, search, profile, list, forget). Управляй памятью Agent командами на естественном языке."
tags:
  - "Использование инструментов"
  - "Управление памятью"
  - "Основные функции"
prerequisite:
  - "start-getting-started"
order: 2
---

# Набор инструментов: научить Agent запоминать

## Что вы сможете сделать после изучения

В этом уроке вы освоите основной способ взаимодействия с плагином `supermemory`. Хотя Agent обычно автоматически управляет памятью, как разработчик вам часто нужно вручную вмешиваться.

После изучения этого урока вы сможете:
1.  Использовать режим `add` для ручного сохранения ключевых технических решений.
2.  Использовать режим `search` для проверки того, запомнил ли Agent ваши предпочтения.
3.  Использовать `profile` для просмотра "вас" в глазах Agent.
4.  Использовать `list` и `forget` для очистки устаревших или неверных памятей.

## Основная идея

opencode-supermemory — не черный ящик, он взаимодействует с Agent через стандартный протокол OpenCode Tool. Это означает, что вы можете вызывать его как функцию, а также управлять им естественным языком.

Плагин регистрирует для Agent инструмент с именем `supermemory`, который похож на швейцарский нож и имеет 6 режимов:

| Режим | Функция | Типичный сценарий |
|--- | --- | ---|
| **add** | Добавление памяти | "Запомни, в этом проекте нужно использовать Bun" |
| **search** | Поиск памяти | "Я ли говорил раньше, как обрабатывать аутентификацию?" |
| **profile** | Профиль пользователя | Просмотр привычек кодирования, которые Agent резюмировал о вас |
| **list** | Список памятей | Аудит последних 10 сохраненных памятей |
| **forget** | Удаление памяти | Удаление неверной записи конфигурации |
| **help** | Руководство по использованию | Просмотр справочной документации инструмента

::: info Механизм автоматического триггера
Помимо ручного вызова, плагин также следит за содержимым вашего чата. Когда вы говорите на естественном языке "Remember this" или "Save this", плагин автоматически обнаруживает ключевые слова и принудительно заставляет Agent вызывать инструмент `add`.
:::

## Следуйте моему примеру: ручное управление памятью

Хотя мы обычно позволяем Agent автоматически оперировать, при отладке или создании начальной памяти ручной вызов инструментов очень полезен. Вы можете напрямую приказать Agent выполнить эти операции естественным языком в диалоговом окне OpenCode.

### 1. Добавление памяти (Add)

Это наиболее часто используемая функция. Вы можете указать содержимое, тип и область действия памяти.

**Действие**: Скажите Agent сохранить память об архитектуре проекта.

**Входная команда**:
```text
Используйте инструмент supermemory для сохранения памяти:
Содержимое: "Весь код слоя обслуживания этого проекта должен находиться в каталоге src/services"
Тип: architecture
Область: project
```

**Внутреннее поведение Agent** (логика исходного кода):
```json
{
  "tool": "supermemory",
  "args": {
    "mode": "add",
    "content": "Весь код слоя обслуживания этого проекта должен находиться в каталоге src/services",
    "type": "architecture",
    "scope": "project"
  }
}
```

**Что вы должны увидеть**:
Agent возвращает подобное подтверждающее сообщение:
> ✅ Memory added to project scope (ID: mem_12345...)

::: tip Выбор типа памяти (Type)
Для более точного поиска рекомендуется использовать точный тип:
- `project-config`: Технологический стек, конфигурация цепочки инструментов
- `architecture`: Архитектурные шаблоны, структура каталогов
- `preference`: Ваши личные предпочтения кодирования (например, "предпочитаю стрелочные функции")
- `error-solution`: Определенное решение конкретной ошибки
- `learned-pattern`: Наблюдаемые Agent шаблоны кода
:::

### 2. Поиск памяти (Search)

Когда вы хотите убедиться, "знает" ли Agent определенную вещь, можно использовать функцию поиска.

**Действие**: Поиск памяти о "слое обслуживания".

**Входная команда**:
```text
Запрос supermemory, ключевые слова - "services", область - project
```

**Внутреннее поведение Agent**:
```json
{
  "tool": "supermemory",
  "args": {
    "mode": "search",
    "query": "services",
    "scope": "project"
  }
}
```

**Что вы должны увидеть**:
Agent перечисляет релевантные фрагменты памяти и их сходство (Similarity).

### 3. Просмотр профиля пользователя (Profile)

Supermemory автоматически поддерживает "профиль пользователя", содержащий ваши долгосрочные предпочтения.

**Действие**: Просмотр вашего профиля.

**Входная команда**:
```text
Вызовите режим profile инструмента supermemory, посмотрите, что вы обо мне знаете
```

**Что вы должны увидеть**:
Возвращается два типа информации:
- **Static**: Статические факты (например, "пользователь — full-stack разработчик")
- **Dynamic**: Динамические предпочтения (например, "пользователь в последнее время интересуется Rust")

### 4. Аудит и забывание (List & Forget)

Если Agent запомнил неверную информацию (например, устаревший API Key), вам нужно удалить ее.

**Первый шаг: список последних памятей**
```text
Перечислите последние 5 памятей проекта
```
*(Agent вызывает `mode: "list", limit: 5`)*

**Второй шаг: получить ID и удалить**
Предположим, вы видите неверную память с ID `mem_abc123`.

```text
Удалите запись с ID памяти mem_abc123
```
*(Agent вызывает `mode: "forget", memoryId: "mem_abc123"`)*

**Что вы должны увидеть**:
> ✅ Memory mem_abc123 removed from project scope

## Продвинутый уровень: триггеризация естественным языком

Вам не нужно каждый раз подробно описывать параметры инструмента. Плагин имеет встроенный механизм обнаружения ключевых слов.

**Попробуйте**:
В диалоге прямо скажите:
> **Remember this**: вся обработка дат должна использовать библиотеку date-fns, использование moment.js запрещено.

**Что произошло?**
1.  Хук `chat.message` плагина обнаружил ключевое слово "Remember this".
2.  Плагин внедрил в Agent системную подсказку: `[MEMORY TRIGGER DETECTED]`.
3.  Agent получил инструкцию: "You MUST use the supermemory tool with mode: 'add'...".
4.  Agent автоматически извлекает содержимое и вызывает инструмент.

Это очень естественный способ взаимодействия, позволяющий вам в любое время в процессе кодирования "закреплять" знания.

## Частые вопросы (FAQ)

**Q: Что такое `scope` по умолчанию?**
A: По умолчанию `project`. Если вы хотите сохранить предпочтения, общие для всех проектов (например, "я всегда использую TypeScript"), укажите явно `scope: "user"`.

**Q: Почему добавленная память не вступает в силу немедленно?**
A: Операция `add` асинхронная. Обычно Agent сразу "знает" эту новую память после успешного вызова инструмента, но при крайних задержках сети может потребоваться несколько секунд.

**Q: Будет ли загружена конфиденциальная информация?**
A: Плагин автоматически удаляет чувствительное содержимое в тегах `<private>`. Но для безопасности не рекомендуется помещать пароли или API Key в память.

---

## Приложение: справочник по исходному коду

<details>
<summary><strong>Нажмите, чтобы просмотреть расположение исходного кода</strong></summary>

> Время обновления: 2026-01-23

| Функция | Путь к файлу | Номер строки |
|--- | --- | ---|
| Определение инструмента | [`src/index.ts`](https://github.com/supermemoryai/opencode-supermemory/blob/main/src/index.ts#L183-L485) | 183-485 |
| Обнаружение ключевых слов | [`src/index.ts`](https://github.com/supermemoryai/opencode-supermemory/blob/main/src/index.ts#L34-L37) | 34-37 |
| Prompt триггера | [`src/index.ts`](https://github.com/supermemoryai/opencode-supermemory/blob/main/src/index.ts#L20-L28) | 20-28 |
| Реализация клиента | [`src/services/client.ts`](https://github.com/supermemoryai/opencode-supermemory/blob/main/src/services/client.ts) | Полный текст |

**Ключевые определения типов**:
- `MemoryType`: Определено в [`src/types/index.ts`](https://github.com/supermemoryai/opencode-supermemory/blob/main/src/types/index.ts)
- `MemoryScope`: Определено в [`src/types/index.ts`](https://github.com/supermemoryai/opencode-supermemory/blob/main/src/types/index.ts)

</details>

## Предпросмотр следующего урока

> В следующем уроке мы изучим **[Область действия памяти и жизненный цикл](../memory-management/index.md)**.
>
> Вы узнаете:
> - Механизм изоляции User Scope и Project Scope
> - Как разработать эффективную стратегию разделения памяти
> - Управление жизненным циклом памяти
